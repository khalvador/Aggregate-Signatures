	
	\section{Many-to-One Commitments}\label{sec:many-to-one-com}
	In this section, we introduce a notion of a \textit{many-to-one} commitment and show how it can be used to build vector and linear functional commitments. Informally, this primitive takes multiple messages $\Message_1,\ldots,\Message_\arity$ and  produces one common value $C$ in such a way that for each $i=1,2,\ldots,\arity$, the output $C$ is a valid commitment to all  $\Message_i$. For technical, mainly recursive, reasons we will require the message space, opening space and commitment space to be $R$-modules, where $R$ is a commutative ring.
	\begin{definition}[Many-To-One Commitment]
		A many-to-one commitment scheme $\commitment$ with arity $\arity$ is a tuple of algorithms $(\commitment.\setup, \commitment.\keygen, \commitment.\commit,\commitment.\open)$ which satisfies the following:
		\begin{itemize}
                \item $\commitment.\setup(1^\SecParam) = (\MessSpace,\OpenSpace,\OpenHonestSpace,\OpenValidSpace)$ is a deterministic algorithm, which given  the security parameter $\SecParam$ in unary, it outputs the description of: (i) message space $\MessSpace$, (ii) the space of all openings $\OpenSpace$, (iii) the space of valid openings $\OpenValidSpace \subseteq \OpenSpace$, and (iv) the space of honestly generated openings $\OpenHonestSpace \subseteq \OpenValidSpace $ \footnote{In the context of lattice-based cryptography, a standard example is when $\OpenHonestSpace$ consists of vectors of short norms, and $\OpenValidSpace$ contains short linear combinations of elements in $\OpenHonestSpace$.}. Here, both $\MessSpace$ and $\OpenSpace$ are $R$-modules.	
    		\item $\commitment.\keygen(1^\SecParam) \rightarrow \crs:=(\comkey^\star,(\comkey_i,\slack_i)_{i\in [\arity]})$ is a probabilistic algorithm, which given the security parameter $\SecParam$ in unary, outputs the main commitment key $\comkey^\star$, as well as $\arity$ pairs $(\comkey_i,\slack_i)$, where $\comkey_i$ is a partial commitment key, and $\slack_i \in R^\times$ is a slackness factor. 
                %
                \item $\commitment.\commit_{\comkey^\star}(\Message_1,\ldots,\Message_\arity) \rightarrow (C, \Opening_1,\ldots,\Opening_\arity)$ is a probabilistic algorithm, which given the main commitment key $\comkey^\star$ and a vector of messages $(\Message_1,\ldots,\Message_\arity) \in \MessSpace^\arity$, outputs the commitment $C \in \MessSpace$, and $\arity$ openings $\Opening_1,\ldots,\Opening_\arity \in \OpenSpace$.
                %
			\item $\commitment.\open_{\comkey}(\Message, \Opening) = C$ is a deterministic algorithm, which given a partial commitment key $\comkey$, message $\Message \in \MessSpace$, and an opening $\Opening \in \OpenSpace$, outputs the reconstructed commitment $C \in \MessSpace$.
		\end{itemize}
	\end{definition}
	\noindent There are a few changes from the standard notion of a commitment scheme. First, $\commitment.\setup$ outputs the main commitment key $\comkey^\star$ used solely for committing to the messages $\Message_1,\ldots,\Message_\arity$ together. Roughly speaking, $\comkey^\star$ contains additional information which allows to output a value $C$, such that $\slack_i \cdot C$ would be a commitment to the message $\Message_i$ with respect to partial commitment keys $\comkey_i$ for all $i \in [\arity]$. Here, the slackness factors $\slack_i$ will have a crucial role in security of our schemes. Further, the opening function $\commitment.\open_\comkey(\Message,\Opening)$ outputs the \textit{reconstructed} commitment $C$, rather than checking whether $C$ is a commitment to $\Message$ with opening $\Opening$.
	
	We now define the correctness property of a many-to-one commitment. Correctness requires the openings generated by $\commitment.\commit$ to be in the space of honestly generated openings $\OpenHonestSpace$, which is a subset of valid openings $\OpenValidSpace$. 
	\begin{definition}[Correctness]
		A many-to-one commitment $\commitment = (\commitment.\setup, \commitment.\keygen,\commitment.\commit$, $\commitment.\open)$ with arity $\arity$  satisfies correctness if for any unbounded algorithm $\Adversary$ we have
		\[ \scalemath{0.9}{ \Pr\left[
		\begin{matrix}
			\forall i \in [\arity], \left(\commitment.\open_{\comkey_i}(\Message_i, \Opening_i) = \slack_i \cdot C \right) \\  \land   \left(\Opening_i \in \OpenHonestSpace \right)
		\end{matrix}
		\middle|
		\begin{matrix}
                (\MessSpace,\OpenSpace,\OpenHonestSpace,\OpenValidSpace) = \commitment.\setup(1^\SecParam) \\
			\crs:=(\comkey^\star,(\comkey_i,\slack_i)_{i\in [\arity]}) \gets              \commitment.\keygen(1^\SecParam) \\
                (\Message_1,\ldots,\Message_\arity) \gets \Adversary(\crs) \\
			(C, \Opening_1,\ldots,\Opening_\arity) \gets \commitment.\commit_{\comkey^\star}(\Message_1,\ldots,\Message_\arity)
		\end{matrix}\right] \geq 1 - \negl.} \]
	\end{definition}
 
    \noindent As noted in the definition of correctness, $\commitment.\open_{\comkey_i}(\Message_i, \Opening_i)$ outputs the original commitment up to a scalar $\slack_i \in R$, which we call the slackness factor. It is very natural to consider simple many-to-one commitments, where these factors are all equal to one. We call such commitments \textit{exact} and they will be crucial for building vector commitments. 

    \begin{definition}[Exactness]
        A many-to-one commitment $\commitment = (\commitment.\setup, \commitment.\keygen,\commitment.\commit$, $\commitment.\open)$ with arity $\arity$ is exact if 
        \[
         \Pr\left[
		\begin{matrix}
			\slack_1 = \ldots = \slack_\arity = 1
		\end{matrix}
		\middle|
		\begin{matrix}
			(\comkey^\star,(\comkey_i,\slack_i)_{i\in [\arity]}) \gets \commitment.\keygen(1^\SecParam) \
		\end{matrix}\right] = 1.
        \]
    \end{definition}
    
    \noindent Next, we turn to describing the binding property. Intuitively, one reasonable definition of a binding game in this case would be  as follows, call it $1$-binding. An adversary is given the output $(\comkey^\star,(\comkey_i,\slack_i)_{i\in [\arity]})$ from the setup algorithm $\commitment.\setup$, and provides an index $i \in [\arity]$, for which it tries to find two messages-opening pairs $(\Message^*_0,\Opening^*_0), (\Message^*_1,\Opening^*_1)$ such that $\Message^*_0 \neq \Message^*_1$ and  $\commitment.\open_{\comkey_i}(\Message^*_0, \Opening^*_0) = \commitment.\open_{\comkey_i}(\Message^*_1, \Opening^*_1)$.
    
    Since the output of the opening function lies in the message space, we can consider a natural generalisation of the binding game above, call it $2$-binding. Namely, suppose the adversary now obtains two outputs $(\comkey^\star_1,(\comkey_{1,i},\slack_{1,i})_{i\in [\arity]})$ and $(\comkey^\star_2,(\comkey_{2,i},\slack_{2,i})_{i\in [\arity]})$ from $\commitment.\setup$, and 
	returns two indices $(i_1,i_2)\in [\arity]$, as well as two messages-opening pairs $(\Message^*_0,\Opening^*_0 := (\Opening^*_{0,1},\Opening^*_{0,2})), (\Message^*_1,\Opening^*_1 := (\Opening^*_{1,1},\Opening^*_{1,2}))$ such that $\Message^*_0 \neq \Message^*_1$ and
	\[\scalemath{1}{ \commitment.\open_{\comkey_{2,i_1}}( \commitment.\open_{\comkey_{1,i_1}}(\Message^*_0, \Opening^*_{0,1}),\Opening^*_{0,2}) =  \commitment.\open_{\comkey_{2,i_2}}( \commitment.\open_{\comkey_{1,i_1}}(\Message^*_1, \Opening^*_{1,1}),\Opening^*_{1,2}).}\]
	One can show that $2$-binding naturally reduces to $1$-binding. We generalise this approach to define a notion called $h$-binding for $h \geq 1$. Further, we consider the additional requirement that the messages sent by the adversary need to be in a certain subset $\BindingSet$ of the message space. This is fairly common in the setting of lattice-based commitments, where this \textit{binding set} consists of vectors of short norm. We are now ready to formally define $(h,\BindingSet)$-binding.
	\begin{definition}[Binding]
		Let $h \geq 1$ and $\BindingSet = (\BindingSet_\SecParam)_{\SecParam \in \NN}$ be a sequence of sets. A many-to-one commitment scheme $\commitment = (\commitment.\setup, \commitment.\keygen,\commitment.\commit,\commitment.\open)$ with arity $\arity$ over $M$ is $(h,\BindingSet)$-binding if for every PPT adversary $\adv$, the following holds:
		\[\scalemath{0.87}{ \Pr\left[
			\begin{matrix}
				\left(\recopen_{\ck^*}(\Message^*_0,\Opening^*_0) = \recopen_{\ck^*}(\Message^*_1,\Opening^*_1)\right) \\
				\land (\Message^*_0,\Message^*_1 \in \BindingSet_\SecParam) \land (\Message^*_0 \neq \Message^*_1) \land (\Opening^*_0,\Opening^*_1 \in \OpenValidSpace^h)
			\end{matrix}
			\middle|
			\begin{matrix}
                     (\MessSpace,\OpenSpace,\OpenHonestSpace,\OpenValidSpace) = \commitment.\setup(1^\SecParam)  \\ 
				\crs:=(\comkey^\star_j,(\comkey_{j,i},\slack_{j,i})_{i\in [\arity]})_{j \in [h]} \gets              \commitment.\keygen(1^\SecParam) \\
				\left(\idx^*, (\Message^*_0,\Opening^*_0),(\Message^*_1,\Opening^*_1) \right) \gets \adv(\crs) \\
				\idx^* := (i_1,\ldots,i_h) \in [\arity]^h \\
				\ck^* := (\ck_{1,i_1},\ldots,\ck_{h,i_h}) \\
			\end{matrix}\right] \leq \negl,} \]
		where the levelled opening function $\recopen_{\ck'}(\Message',\Opening')$ for input partial commitment keys $\ck'$, message $\Message' \in \MessSpace$, and openings $\Opening' \in \OpenSpace^h$ is defined in \Cref{fig:levelopen}.
	\end{definition}

	\begin{figure}[t]
		\centering
			\fbox{
				\begin{minipage}[t]{0.5\textwidth}
					\underline{$\recopen_{(\ck'_1,\ldots,\ck'_h)}(\Message',\Opening' = (\Opening'_1,\ldots,\Opening'_h))$}
					\begin{algorithmic}[1]
                            \item $Y_h := \Message'$
                            \item $\pcfor j = h-1,\ldots,1,0:$
                            \item \quad $Y_j := \commitment.\open_{\ck'_{j+1}}(Y_{j+1},\Opening'_{j+1})$
                            \item $\pcreturn Y_0 \in \MessSpace$.
					\end{algorithmic}
				\end{minipage}
		}
		\caption{Levelled opening function used for binding.}\label{fig:levelopen}
	\end{figure}
    \noindent Further, we introduce a notion of linear homomorphism for many-to-one commitments. Informally, we want the $\open$ function to be homomorphic over its domain $\MessSpace \times \OpenSpace$ for the same commitment key $\comkey$:
    \[ \commitment.\open_{\ck}(\alpha\Message_0 + \beta\Message_1,  \alpha\Opening_0+\beta \Opening_1 ) = \alpha \cdot \commitment.\open_{\ck}(\Message_0, \Opening_0) +  \beta \cdot \commitment.\open_{\ck}(\Message_1, \Opening_1)\]
    for any $\alpha,\beta \in R$. However, recall that many-to-one commitments produce a single value, which is simultaneously a commitment to all given message under \textit{different} partial commitment keys. In order to make use of the aforementioned property of $\open$, we require the $\keygen$ algorithm to always output the same partial commitment keys $\comkey := \comkey_1=\ldots=\comkey_\arity$. 
    %
    %By combining both conditions, we can deduce that if $(\comkey^\star,(\comkey,\slack_i)_{i\in [\arity]}) \gets \commitment.\keygen(1^\SecParam)$ and $(C, \Opening_1,\ldots,\Opening_\arity) \gets \commitment.\commit_{\comkey^\star}(\Message_1,\ldots,\Message_\arity)$ for arbitrary messages $\Message_1,\ldots,\Message_\arity \in \MessSpace$, then for any scalars $\alpha_1,\ldots,\alpha_\arity \in R$:
    %\[ \commitment.\open_{\comkey}\left(\sum^\arity_{i=1}\alpha_i \Message_i, \sum^\arity_{i=1}\alpha_i \Opening_i\right) = \left(\sum^\arity_{i=1} \alpha_i\slack_i\right) \cdot C.\]
    %One can already build a naive linear functional commitment for vectors of length $\arity$ as follows. Suppose we want to commit to a vector $\vecx = (x_1,\ldots,x_\kappa) \in R$. Take an element $P \in \MessSpace$ and run $(C, \Opening_1,\ldots,\Opening_\arity) \gets \commitment.\commit_{\comkey^\star}(x_1 \cdot P,\ldots,x_\arity \cdot P)$. Then, the commitment becomes $C$. Now, to prove a linear relation, e.g. $\sum^\kappa_{i=1} \alpha_i \cdot x_i = z$, we perform the homomorphic operations as described above to get:
    %\[ \commitment.\open_{\comkey}\left(\left(\sum^\arity_{i=1}\alpha_i x_i\right) \cdot P, \sum^\arity_{i=1}\alpha_i \Opening_i\right) = \left(\sum^\arity_{i=1} \alpha_i\slack_i\right) \cdot C.\]
    %Thus, the opening for the linear function characterised by $(\alpha_1,\ldots,\alpha_\arity)$ is $\Proof :=  \sum^\arity_{i=1}\alpha_i \Opening_i$. Finally, the verification algorithm takes $C,\Proof,(\alpha_1,\ldots,\alpha_\arity),z$ and checks whether $\commitment.\open_{\comkey}\left(z \cdot P, \Proof\right) = \left(\sum^\arity_{i=1} \alpha_i\slack_i\right) \cdot C$.
    We formalise these two conditions as follows.
    \begin{definition}[Linear Homorphism]
        Let  $\commitment = (\commitment.\setup, \commitment.\keygen,\commitment.\commit,\commitment.\open)$ be a many-to-one commitment with arity $\kappa$. We say that $\commitment$ is linearly homomorphic if for every $\SecParam \in \NN$ the following hold:
        \begin{itemize}
            \item $
                     \Pr\left[
                    \begin{matrix}
                        \comkey_1 = \ldots = \comkey_\arity
                    \end{matrix}
                    \middle|
                    \begin{matrix}
                        (\comkey^\star,(\comkey_i,\slack_i)_{i\in [\arity]}) \gets \commitment.\keygen(1^\SecParam) \
                    \end{matrix}\right] = 1$,
              \item For every key $\comkey$, and every two triples $(\Message_0,\Opening_0, \alpha_0), (\Message_1,\Opening_1, \alpha_1)  \in \MessSpace \times \OpenSpace \times R$:
              \[ \commitment.\open_{\ck}(\alpha_0 \Message_0 + \alpha_1 \Message_1, \alpha_0 \Opening_0 + \alpha_1 \Opening_1 ) = \alpha_0 \cdot \commitment.\open_{\ck}(\Message_0, \Opening_0) + \alpha_1 \cdot \commitment.\open_{\ck}(\Message_1, \Opening_1) \]
              where $(\MessSpace,\OpenSpace,\OpenHonestSpace,\OpenValidSpace) = \commitment.\setup(1^\SecParam)$.
        \end{itemize}
    \end{definition}
    \noindent Unfortunately, by introducing additional structure on the commitment, one can easily break the $1$-binding property if the set of valid openings $\OpenValidSpace$ is large enough. To showcase the intuition, suppose $\OpenValidSpace = \OpenSpace$. Since the relaxation factors $\slack_i$ are invertible over $R$, if $\arity \geq 2$ then it is trivial to find non-zero $\beta_1,\ldots,\beta_\arity \in R$ such that
    \[ \beta_1\slack_1 + \ldots + \beta_\arity\slack_\arity  = 0.\]
    Hence, if $\sum^\arity_{i=1}\alpha_i \Message_i \neq \sum^\arity_{i=1}(\alpha_i + \beta_i) \Message_i$ then we broke the binding property since
    \[ \commitment.\open_{\comkey}\left(\sum^\arity_{i=1}\alpha_i \Message_i, \sum^\arity_{i=1}\alpha_i \Opening_i\right) = \commitment.\open_{\comkey}\left(\sum^\arity_{i=1}(\alpha_i+\beta_i) \Message_i, \sum^\arity_{i=1}(\alpha_i+\beta_i)\Opening_i\right),\]
    and both $\sum^\arity_{i=1}\alpha_i \Opening_i$ and $\sum^\arity_{i=1}(\alpha_i+\beta_i)\Opening_i$ lie in the space of valid openings $\OpenValidSpace=\OpenSpace$. Hence, when proving binding for linearly homomorphic many-to-one we will need to provide conditions on $\OpenValidSpace$. 

	\subsection{Vector Commitments}
        We formally describe the vector commitment construction from exact many-to-one commitments in \Cref{fig:vectorcommitment} and below we provide some intuition. In the following, fix the security parameter $\SecParam$ and define $(\MessSpace,\OpenSpace,\OpenHonestSpace,\OpenValidSpace) = \commitment.\setup(1^\SecParam)$.
 
    Suppose we want to commit to vectors of length $\veclength = \arity^h$, and let us denote them as $\vecx := (x_{\veci})_{ \veci \in [\arity]^{h}} \in R^\veclength$, e.g. $\vecx := (x_{(1,1)},x_{(1,2)},x_{(2,1)},x_{(2,2)})$. Our construction takes key ideas from Merkle trees. Namely, consider a standard complete $\arity$-tree with nodes indexed by $\veci \in [\arity]^{\leq h}$ (including the empty string $\emptystring$ which denotes the root). For each $j$-th level of the tree, we use new public parameters from the exact many-to-one commitment 
	\[(\comkey^\star_j,(\comkey_{j,i},1)_{i\in [\arity]}) \gets \commitment.\keygen(1^\SecParam) \quad \text{for } j=1,2,\ldots,h. \]
	Further, we define the \textit{leaf} commitments $C_{\veci} := x_{\veci} \cdot P$, where $\veci \in [\arity]^h$ and $P$ is a fixed element of $\MessSpace$. Now we are ready to define the \textit{parent} commitments. Concretely, for any $\veci \in [\arity]^{\leq h - 1}$, we compute
	\[ (C_{\veci}, \Opening_{(\veci,1)},\ldots,\Opening_{(\veci,\arity)}) \gets \commitment.\commit_{\comkey^\star_j}(C_{(\veci,1)},\ldots,C_{(\veci,\arity)}),\]
	where $j := |\veci| +1$ and $(\veci,\iota)$ is denoted to be the vector $\veci$ with $\iota \in [\arity]$ appended at the end. Finally, the commitment to $\vecx$ is the value $C_\emptystring \in \MessSpace$.
	
	Now, suppose we want to provide an opening to an index $\veci = (i_1,\ldots,i_h) \in [\arity]^h$. To this end, consider the following sequence $(Y_0,Y_1,\ldots,Y_{h}) \in \MessSpace^{h+1}$, where
	\[ Y_j := \begin{cases} x_\veci \cdot P \quad \text{if } j = h, \\
		 \commitment.\open_{\comkey_{j+1,i_{j+1}}}(Y_{j+1}, \Opening_{(i_1,\ldots,i_{j+1})}) \quad \text{if } j < h.
	\end{cases}\]
	Suppose the underlying many-to-one commitment satisfies correctness and exactness. Then, one observes that the sequence is well-defined, and more importantly, by induction 
	\[ Y_j  = C_{(i_1,\ldots,i_{j})} \quad \text{for } j=0,1,\ldots,h.\]
	In particular, $Y_0$ is equal to $C_\emptystring$. Therefore, we let the opening for index $\veci$ consist of the partial openings 
	\[\Proof := (\Opening_{i_1}, \Opening_{(i_1,i_2)},\ldots,\Opening_{(i_1,\ldots,i_h)})\]
	of nodes on the path from the leaf $\veci$ to (and excluding) the root $\emptystring$. Hence by definition, given index $\veci$, opening $\Proof$ and the claimed value $x_\veci$, a verifier can compute $Y_0$ as above and check whether $Y_0 \stackrel{?}{=} C_\emptystring$.
	
	\begin{figure}[t]
		\centering
		\resizebox{.9\linewidth}{!}{
			\fbox{
				\begin{minipage}[t]{0.55\textwidth}
					\underline{$\veccomsetup(\secparam, 1^{\veclength})$}
					\begin{algorithmic}[1]
                            \item $\PublicParam = \commitment.\setup(1^\SecParam)$
						\item $\pcfor j \in [h]:$
						\item $\quad (\comkey^\star_j,(\comkey_{j,i},\slack_{j,i})_{i\in [\arity]}) \gets \commitment.\keygen(1^\SecParam)$
						\item $\pcreturn \crs \coloneqq \left(\PublicParam, (\comkey^\star_j,(\comkey_{j,i},\slack_{j,i})_{i\in [\arity]})_{j \in [h]} \right)$
					\end{algorithmic}
					
					\underline{$\veccomcommit(\crs, (x_{\veci})_{\veci \in [\arity]^h} \in R^{\veclength})$}
					\begin{algorithmic}[1]
						\item $\crs \coloneqq \left(\PublicParam, (\comkey^\star_j,(\comkey_{j,i},\slack_{j,i})_{i\in [\arity]})_{j \in [h]} \right)$
						\item \texttt{$\backslash \backslash$ defining leaves}
						\item \pcfor $\veci \in [\arity]^h$:
						\item \quad $C_{\veci} := x_{\veci} \cdot P_\SecParam$
						\item \texttt{$\backslash \backslash$ building a tree}
						\item $\pcfor j = h-1,\ldots,1,0$:
						\item \quad $\pcfor \veci \in [\arity]^j$:
						\item \quad \quad $(C_\veci, \Opening_\veci) \gets \commitment.\commit_{\comkey^\star_j}(C_{(\veci,1)},\ldots,C_{(\veci,\arity)})$
						\item $\sigma := C_{\emptystring}$
						\item $\matrixstate := \left\{ \Opening_{\veci} : \veci \in [b]^{\leq h-1}\right\}$
						\item \Return $\sigma$, $\matrixstate$
					\end{algorithmic}
				\end{minipage}
				\begin{minipage}[t]{0.55\textwidth}
					\underline{$\veccomopen(\crs, \veccomstate, \veci := (i_1,\ldots,i_h) \in [\arity]^h)$}
					\begin{algorithmic}[1]
						\item $\matrixstate := \left\{ \Opening_{\veci} : \veci \in [b]^{\leq h-1}\right\}$
						\item \Return $\Proof := (\Opening_{i_1},\Opening_{(i_1,i_2)},\ldots,\Opening_{(i_1,i_2,\ldots,i_h)})$
					\end{algorithmic}
					\underline{$\verify(\crs, \sigma, \veci \in [d]^h ,  y, \Proof)$}
					\begin{algorithmic}[1]
						\item $\Proof := (\Proof_1,\ldots,\Proof_{h})$
						\item $Y_{h+1} := y \cdot P_\SecParam$
						\item $\pcfor j = h-1,\ldots,1,0$:
						\item \quad $Y_{j} := \commitment.\open_{\ck_{j+1,i_{j+1}}}(Y_{j+1}, \Proof_{j+1})$
						\item \pcif $Y_0 = \sigma \land \Proof \in \OpenValidSpace^h$ \pcthen \pcreturn $1$
						\item \pcelse \pcreturn $0$
					\end{algorithmic}
				\end{minipage}
		}}
		\caption{Vector commitment $\veccom[P,\commitment]$ from the sequence $P = (P_\SecParam)_{\SecParam \in \NN}$, and the exact many-to-one commitment $\commitment = (\commitment.\setup, \commitment.\keygen,\commitment.\commit,\commitment.\open)$ with arity $\kappa$. Here, we commit to vectors in $R^\veclength$, where $\veclength = \arity^h$.}\label{fig:vectorcommitment}
	\end{figure}
	
	\paragraph{Security analysis.} Below we show correctness and binding property of the newly described vector commitment. In particular, we need the exactness requirement for correctness, but not for binding.

    \begin{lemma}\label{lem:VC-correctness}
    Let  $\commitment = (\commitment.\setup, \commitment.\keygen,\commitment.\commit,\commitment.\open)$ be an exact many-to-one commitment with arity $\kappa$, and take any sequence $P = (P_\SecParam)_{\SecParam \in \NN}$ such that for every $\SecParam \in \NN, P_\SecParam \in \MessSpace$ where $ (\MessSpace,\OpenSpace,\OpenHonestSpace,\OpenValidSpace) = \commitment.\setup(1^\SecParam)$. If $\commitment$ is correct, then the vector commitment $\veccom[P,\commitment]$ in \Cref{fig:vectorcommitment} satisfies correctness.
    \end{lemma}
    \begin{proof}
     Take an arbitrary vector $\vecx := (x_{\veci})_{\veci \in [\arity]^h} \in R^{\veclength}$, where $\veclength = \poly(\SecParam)$, and an index $\veci := (i_1,\ldots,i_h) \in [\arity]^h$. Then, by exactness of $\commitment$ we have $\crs :=(\comkey^\star_j,(\comkey_{j},1)_{i\in [\arity]}) \gets \commitment.\setup(1^\SecParam)$. Consider $(\sigma,\matrixstate) \gets \veccomcommit(\crs,\vecx)$. By correctness of $\commitment$ and the union bound, $\matrixstate$ consists of valid openings in $\OpenSpace$. In particular, the opening $\Proof = (\Opening_{i_1},\Opening_{(i_1,i_2)},\ldots,\Opening_{(i_1,i_2,\ldots,i_h)}) \gets \veccomopen(\crs, \veccomstate, \veci)$ lies in $\OpenHonestSpace^h \subseteq \OpenValidSpace^h$. Finally, we need to show that with high probability $Y_0$ computed in $\verify(\crs, \veccomstate, \veci,x_{\veci},\Proof)$ is indeed equal to $\sigma = C_\emptystring$. To this end, we prove by induction that with high probability \[Y_j = C_{(i_1,\ldots,i_{j})} \quad \text{for } j=0,1,\ldots,h.\]
    Consider the base case $j=h$. Then, $Y_h = x_{\veci} \cdot P_\SecParam$ and similarly $C_\veci = x_{\veci} \cdot P_\SecParam$ since it is a \textit{leaf} commitment. Now, suppose $Y_{j+1} = C_{(i_1,\ldots,i_{j+1})}$ for some $j \leq h-1$. Then, by definition of $Y_j$ and correctness of $\commitment$ we deduce that with high probability:
    \begin{align*}
        Y_j &=  \commitment.\open_{\ck_{j+1,i_{j+1}}}(Y_{j+1}, \Opening_{(i_1,\ldots,i_{j+1})}) =  \commitment.\open_{\ck_{j+1,i_{j+1}}}(C_{(i_1,\ldots,i_{j+1})},  \Opening_{(i_1,\ldots,i_{j+1})}) =  C_{(i_1,\ldots,i_{j})}
    \end{align*}
     which concludes the proof.
    \end{proof}
    
    \begin{lemma}\label{lem:VC-binding}
    Let  $\commitment = (\commitment.\setup, \commitment.\keygen,\commitment.\commit,\commitment.\open)$ be a many-to-one commitment with arity $\kappa$, and take any sequence $P = (P_\SecParam)_{\SecParam \in \NN}$ such that for every $\SecParam \in \NN, P_\SecParam \in \MessSpace$ and $\ann_R(P_\SecParam) = \{0\}$, where $ (\MessSpace,\OpenSpace,\OpenHonestSpace,\OpenValidSpace) = \commitment.\setup(1^\SecParam)$. If $\commitment$ is $(h,\BindingSet := (\BindingSet_\SecParam)_{\SecParam \in \NN})$-binding, where \[\BindingSet_\SecParam := \{ x \cdot P_\SecParam : x \in R\},\] then the vector commitment $\veccom[P,\commitment]$ in \Cref{fig:vectorcommitment} satisfies binding.
    \end{lemma}
    \begin{proof}
    Let $\Adversary$ be an adversary against the binding game for the vector commitment in \Cref{fig:vectorcommitment}. We describe the algorithm $\AltAdversary$, which breaks binding of $\commitment$ as follows. First, $\AltAdversary$ is given the collection of commitment keys  $\crs:= (\comkey^\star_j,(\comkey_{j,i},\slack_{j,i})_{i\in [\arity]})_{j \in [h]} \gets \commitment.\setup(1^\SecParam)$. Then, $\AltAdversary$ runs $\Adversary(\crs)$  to obtain $(\sigma,\veci,(x_\veci,\Proof), (x'_\veci,\Proof'))$. Finally, the reduction $\AltAdversary$ outputs $(\veci,(x_\veci \cdot P_\SecParam,\Proof), (x'_\veci \cdot P_\SecParam,\Proof'))$ to the adversary.

    Suppose $\Adversary$ succeeds in breaking the binding property. Thus, $x_\veci \neq x'_\veci$ and
    \[ \verify(\crs,\sigma,\veci,x_\veci,\Proof) = 1 = \verify(\crs,\sigma,\veci,x'_\veci,\Proof').\]
    The main observation here is that
    \[ \verify(\crs,\sigma,\veci,x_\veci,\Proof) = 1 \iff (\recopen_{\comkey^*}(x_\veci \cdot P_\SecParam, \Proof) = \sigma) \land (\Proof \in \OpenValidSpace^h)\]
    where $\comkey^* := (\comkey_{1,i_1},\ldots,\comkey_{h,i_h})$. Arguing similarly for $(x'_\veci \cdot P_\SecParam,\Proof')$, we deduce that $\Proof,\Proof' \in \OpenValidSpace^h$ and
    \[\recopen_{\comkey^*}(x_\veci \cdot P_\SecParam, \Proof) = \sigma = \recopen_{\comkey^*}(x'_\veci \cdot P_\SecParam, \Proof').\]
    Finally, $x_\veci \neq x'_\veci$ implies that $x_\veci \cdot P_\SecParam \neq x'_\veci \cdot P_\SecParam$, and therefore $\AltAdversary$ breaks binding.
    \end{proof}


%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%

	\subsection{Linear Functional Commitments}\label{subsec:linfunct-commit}
    Next, we show how to build functional commitments specifically for linear functions. This will be a base case for proving higher-degree equations, such as R1CS. One key notion, which we will use throughout this subsection, is called \textit{linear decomposition}.

    \begin{definition}[Linear Decomposition]
        Let $D$ be a non-empty subset of a ring $R$. We say that $R$ is linearly decomposable by $D \subseteq R$ if there exists a primitive set $G = \{g_1,\ldots,g_\delta\} \subset R$, such that every element $x \in R$ can be uniquely written as $x = \sum^{\delta}_{i = 1} \mu_i \cdot g_i$, where $\mu_i \in D$ and $g_i \in G$. Thus, we can define the following decomposition function
        \[ \Decompose(x) := (\mu_1,\ldots,\mu_\delta) \in D^\delta.\]
    \end{definition}
    \begin{example}
        One can check that $R$ is linearly decomposable by $D = R$. Indeed, by taking $G = \{1\}$ it is easy to see that any element $x \in R$ can be written uniquely as $x = x \cdot g$, where $g \in G$. Another example we will use in this paper is the cyclotomic ring $\ring_q = \ZZ_q[X]/(X^N+1)$ and the set of polynomials with binary coefficients $D = S_1$. Then, one can show that $R_q$ is linearly decomposable by $S$ by taking the set $G := \{1,2,4,\ldots,2^{\lfloor \log q \rfloor}\}$.
    \end{example}
    
	\begin{figure}[t]
		\centering
		\resizebox{\linewidth}{!}{
			\fbox{
				\begin{minipage}[t]{0.50\textwidth}
					\underline{$\veccomsetup(1^{\secparam}, 1^{\veclength})$}
					\begin{algorithmic}[1]
                        \item $\PublicParam = \commitment.\setup(1^\SecParam)$
						\item $\pcfor j \in [h]:$
						\item $\quad (\comkey^\star_j,(\comkey_{j,i},\slack_{j,i})_{i\in [\arity]}) \gets \commitment.\keygen(1^\SecParam)$
						\item $\pcreturn \crs \coloneqq \left(\PublicParam, (\comkey^\star_j,(\comkey_{j,i},\slack_{j,i})_{i\in [\arity]})_{j \in [h]} \right)$
					\end{algorithmic}
					
					\underline{$\veccomcommit(\crs, (x_{\veci})_{\veci \in [d]^h} \in R^{\veclength})$}
					\begin{algorithmic}[1]
						\item $\crs \coloneqq \left(\PublicParam, (\comkey^\star_j,(\comkey_{j,i},\slack_{j,i})_{i\in [\arity]})_{j \in [h]} \right)$
						\item \texttt{$\backslash \backslash$ base case}
						\item \pcfor $\veci \in [b]^h$:
						\item \quad $C_{\veci} := x_{\veci} \cdot P_\SecParam$
						\item \texttt{$\backslash \backslash$ building a tree}
						\item $\pcfor j = h-1,\ldots,1,0$:
						\item \quad $\pcfor \veci \in [b]^j$:
						\item \quad \quad $\matC^\star_\veci := (C_{(\veci,1)},\ldots,C_{(\veci,b)}) \otimes \vecg  \in \MessSpace^{\arity}$
						\item \quad \quad $(C_\veci, \Opening_\veci) \gets \commitment.\commit(\comkey^\star_j,\matC^\star_\veci)$
						\item $\sigma := C_{\emptystring}$
						\item $\matrixstate := \left\{ \Opening_{\veci} : \veci \in [b]^{\leq h-1}\right\}$
						\item \Return $\sigma$, $\matrixstate$
					\end{algorithmic}
				\end{minipage}
				\begin{minipage}[t]{0.55\textwidth}
					\underline{$\veccomopen(\crs, \veccomstate, (p_{\veci})_{\veci \in [d]^h} \in R^{\veclength})$}
					\begin{algorithmic}[1]
						\item $\matrixstate := \left\{ \Opening_{\veci} : \veci \in [b]^{\leq h-1}\right\}$
						\item $\pcfor j = h-1,\ldots,1,0$:
						\item \quad $\Proof_j = 0$
						\item \quad $\pcfor \veci \in [b]^j$:
						\item \quad \quad $\Opening_\veci := (\Opening_{(\veci,1)},\ldots,\Opening_{(\veci,\arity)})$
						\item \quad \quad $\pcfor t \in [b]$:
						\item \quad \quad \quad  $\left(p^{(1)}_{(\veci,t)}, \ldots,  p^{(\delta)}_{(\veci,t)}\right) := \Decompose(p_{(\veci,t)}) \in S^{\delta}$
						\item \quad \quad $\Proof_j := \Proof_j +  \sum_{t=0}^{b-1} \sum^{\delta-1}_{\eta = 0} p^{(\eta)}_{(\veci,t)} \cdot \Opening_{\veci,t\delta+ \eta+1} $
						\item \Return $\pi := (\Proof_0,\ldots,\Proof_{h-1})$
					\end{algorithmic}
					\underline{$\verify(\crs, \sigma, (p_{\veci})_{\veci \in [d]^h} ,  y, \pi)$}
					\begin{algorithmic}[1]
     					\item $\crs \coloneqq \left(\PublicParam, (\comkey^\star_j,(\comkey_{j,i},\slack_{j,i})_{i\in [\arity]})_{j \in [h]} \right)$
                        \item $(\comkey_1,\ldots,\comkey_h) := (\comkey_{j,1},\ldots,\comkey_{h,1})$
						\item $\pi := (\Proof_0,\ldots,\Proof_{h-1})$
						\item $V_h := y \cdot P_\SecParam$
						\item $\pcfor j = h-1,\ldots,1,0$:
						\item \quad $\pcfor \veci \in [b]^j$:
						\item \quad \quad $\pcfor t \in [b]$:
						\item \quad \quad \quad  $\left(p^{(1)}_{(\veci,t)}, \ldots,  p^{(\delta)}_{(\veci,t)}\right) := \Decompose(p_{(\veci,t)}) \in D^{\delta}$
						\item \quad \quad $p_\veci := \sum_{t=1}^{b} \sum^{\delta}_{\eta = 1} p^{(\eta)}_{(\veci,t)} \cdot \slack_{j,(t-1)\delta + \eta}$
						\item \quad $V_{j} := \commitment.\open(\ck_j, V_{j+1}, \Proof_j)$
						\item \pcif $V_0 = p_\emptystring \cdot \sigma$ \pcthen \pcreturn $1$
						\item \pcelse \pcreturn $0$
					\end{algorithmic}
				\end{minipage}
		}}
		\caption{Linear functional commitment from the exact many-to-one commitment $\commitment$ with arity $\kappa = b \delta$. Here, we commit to vectors in $R^\veclength$, where $\veclength = b^h$.}\label{fig:linfunccommitment}
	\end{figure}
	
	\subsection{Functional Commitments for R1CS}
	
	\section{Exotic Lattice-Based Assumptions Revisited}\label{sec:lattice-assumptions}
	
We consider the following computational problem which is a ring generalisation of BASIS~\cite{EPRINT:WeeWu22}.

\begin{definition}[ring-BASIS]\label{def:ring-basis}
Let \(\mat{A}  \sample \mathcal{U}(\ring_{q}^{\eta \times \ell})\), \(w_{i} \sample \mathcal{U}(\ring_q^*)\) for \(i \in \{0,1\}\). Given \(\mat{T}_{j} \in \times \ring^{\ell \times \kappa}\) with \(\|\mat{T}_{i}\| \leq \beta\) for \(j \in \{0,1,2\}\) s.t. \(w_{i} \cdot \mat{A} \cdot \mat{T}_{i} - \mat{G} \cdot \mat{T}_{2} = \mat{0} \in \ring_{q}^{\eta \times \kappa}\), find
\(\vec{u}\) s.t. \(\mat{A} \cdot \vec{u} \equiv \vec{0} \bmod q\) and \(\|\vec{u}\| \leq \beta\).

\end{definition}

\begin{remark}
We set \(\mat{0}\) as targets instead of \(\mat{G}\) (for \(i=0\)) and \(\mat{0}\) (for \(i=1\)) because both are essentially equivalent and we find the former easier to work with.
\end{remark}

The key difference between ring-BASIS and BASIS is that we replace \(\mat{W}_{i} \in \ring_{q}^{\eta \times \eta}\) by \(w_{i} \in \ring_{q}\). In particular, these \(w_{i}\) now commute, which is critical to our application. The natural question is whether this weakens the security of our scheme.

We thus consider  attack strategies of using the commutative properties. From
\begin{align*}
\mat{0} & \equiv w_{0} \cdot \mat{A} \cdot \mat{T}_{0} - \mat{G} \cdot \mat{T}_{2} \text{ and}\\
\mat{0} & \equiv w_{1} \cdot \mat{A} \cdot \mat{T}_{1} - \mat{G} \cdot \mat{T}_{2}
\end{align*}
we get
\begin{align*}
\mat{0} & \equiv w_{0} \cdot \mat{A} \cdot \mat{T}_{0} -  w_{1} \cdot \mat{A} \cdot \mat{T}_{1}\\
        & \equiv \mat{A} \cdot \left(w_{0} \cdot \mat{T}_{0} -  w_{1} \cdot \mat{T}_{1} \right).
\end{align*}
We can thus search for some \(u \in \ring_{q}\) such that \(u \cdot (w_{0} \cdot \mat{T}_{0} -  w_{1} \cdot \mat{T}_{1})\) is short. Assume this \emph{attack} is easy. Then we can solve Ring-LWE or NTRU\@.

Let \((a,b) \in \ring_{q}^{2}\)  be a tuple we want to solve decision LWE on. Set \(w_{0} \coloneqq a\). Sample short \(f,g \in \ring\) and set \(w_{1} \coloneqq  f/g \in \ring_{q}\). Sample short. \(\mat{T}_{i} \in \ring^{\ell \times \kappa}\). Assume there exists and algorithm that outputs \(u\) as above. Write \(t_{0},t_{1}\) for the top-left entry (any entry will do) of \(\mat{T}_{0}\) or \(\mat{T}_{1}\) respectively and let \(z \in \ring\) be short be such that
\begin{align*}
z &\equiv u \cdot (w_{0} \cdot t_{0} -  w_{1} \cdot t_{1})\\
z &\equiv u \cdot (a \cdot t_{0} -  f/g \cdot t_0)\\
g \cdot z &\equiv g \cdot u \cdot a \cdot t_{0} -  f \cdot t_0\\
g \cdot z + f \cdot t_0 &\equiv (g \cdot u \cdot t_{0}) \cdot a
\end{align*}

In other words, \(g \cdot u \cdot t_{0}\) is a short ring element that when multiplied with \(a\) produces a short ring element \(g \cdot z + f \cdot t_0\). An algorithm that produces such a pair \(x,y\), where \(x\) and \(y \equiv x \cdot a\) are short, solves decision ring-LWE via the (normal-form of the) "dual attack" \cite{USENIX:ADPS16,EC:Albrecht17}: Briefly, compute \(x \cdot b\) which is \(x \cdot (a \cdot s + e) = y\cdot s + x\cdot e\) if the sample is LWE and uniform otherwise.

Of course, our algorithm may refuse to cooperate because \(w_{1} \coloneqq  f/g\) is an NTRU instance instead of uniform. Thus, alternatively NTRU is easy.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Instantiation of Many-to-One Commitments from Lattices}\label{sec:lattice-instantiation}
	In this section, we show two instantiations of Many-to-One Commitments.
	The first one will be used for building vector commitments, while the second for linear functional commitments.
  Both make use of the following subroutine.
  \newcommand{\sampleParams}{\mathsf{sampleParams}}
  \begin{construction}
    \begin{itemize}[noitemsep]
      \item[] $\sampleParams((\matA_i, \matR_i)_{i \in [\arity]}, s)$:
        \begin{enumerate}[nolistsep]
          \item Set \begin{equation*} 
					\matB \coloneqq 
					\left[\begin{array}{@{}ccc|c@{}}
						\matA_1 &        & & -\matG_\q \\ 
						& \ddots & & \vdots \\ 
						& & \matA_\arity & -\matG_\q
					\end{array}\right], 
					\tilde{\matR} \coloneqq
					\begin{bmatrix}
						\matR_{1} & & \\
						& \ddots & \\
						& & \matR_{\arity} \\
						\hline 
						& \matzero^{\q^2 \times \arity \q^2} &
					\end{bmatrix}
					\enspace .
				\end{equation*}
				\item Sample $\matT \from \samplepre(\matB, \tilde{\matR}, \matG_{2\q}, s)$.
        \item Return $(\matB, \matT)$.
        \end{enumerate}
    \end{itemize}
  \end{construction}
	
	\begin{construction}
		Here we set $\q \coloneqq \lceil \log q \rceil$.
		\begin{itemize}[noitemsep]
			\item[] $\commitment.\setup(1^\SecParam) \rightarrow (\comkey^\star,(\comkey_i,\slack_i)_{i\in [\arity]})$:
			\begin{enumerate}[nolistsep]
        \item Sample $(\matA_i, \matR_i)_{i \in [\arity]} \from \trapgen(\secparam, q, m)$.
        \item Compute $(\matB, \matT) \from \sampleParams((\matA_i, \matR_i)_{i \in [\arity]}, s_0)$.
				\item Set $\comkey^\star \coloneqq (\matB, \matT)$.
				\item Set $(\comkey_i, \slack_i) \coloneqq (\matA_i, 1)$ for $i \in [\arity]$.
				\item Return $(\comkey^\star,(\comkey_i,\slack_i)_{i\in [\arity]})$.
			\end{enumerate}
		\end{itemize}
		\begin{itemize}[noitemsep]
			\item[] $\commitment.\commit_{\comkey^\star}(\Message_1,\ldots,\Message_\arity) \rightarrow (C, \Opening_1,\ldots,\Opening_\arity)$.
			\begin{enumerate}[nolistsep]
				\item Set $\matU \coloneqq [\Message_1 \dots \Message_\arity]^\top$.
				\item Sample $[\matV_1 \dots \matV_k \;\vert\; \widehat{\matC}]^\top \from \samplepre(\matB, \matT, \matU, s_1)$.
				\item Set $C \coloneqq \matG \widehat{\matC}$.
				\item Set $\Opening_i \coloneqq \matV_i$ for $i \in [\arity]$.
				\item Return $(C, \Opening_1,\ldots,\Opening_\arity)$.
			\end{enumerate}
		\end{itemize}
		\begin{itemize}[noitemsep]
			\item[] $\commitment.\open_{\comkey}(\Message, \Opening) = C \in M$ 
      \begin{enumerate}[nolistsep]
				\item Return $\comkey \cdot \Opening - \Message$.
			\end{enumerate}
		\end{itemize}
	\end{construction}

\begin{construction}
		Here we set $\q \coloneqq \lceil \log q \rceil$.
		\begin{itemize}[noitemsep]
			\item[] $\commitment.\setup(1^\SecParam) \rightarrow (\comkey^\star,(\comkey_i,\slack_i)_{i\in [\arity]})$:
			\begin{enumerate}[nolistsep]
        \item Sample $(\matA, \matR) \from \trapgen(\secparam, q, m)$.
        \item Sample $\slack_i \from \RingOfIntq^\times$ for $i \in [\arity]$.
        \item Set $\matA_i \coloneqq \slack^{-1}_i \matA$ and $\matR_i \coloneqq \matR \matG^{-1}(\slack_i \matG_\q)$ for $i \in [\arity]$.
        \item Compute $(\matB, \matT) \from \sampleParams((\matA_i, \matR_i)_{i \in [\arity]}, s_0)$.
				\item Set $\comkey^\star \coloneqq (\matB, \matT)$.
				\item Set $\comkey_i \coloneqq \matA_i$ for $i \in [\arity]$.
				\item Return $(\comkey^\star,(\comkey_i,\slack_i)_{i\in [\arity]})$.
			\end{enumerate}
		\end{itemize}
		\begin{itemize}[noitemsep]
			\item[] $\commitment.\commit_{\comkey^\star}(\Message_1,\ldots,\Message_\arity) \rightarrow (C, \Opening_1,\ldots,\Opening_\arity)$.
			\begin{enumerate}[nolistsep]
				\item Set $\matU \coloneqq [\Message_1 \dots \Message_\arity]^\top$.
				\item Sample $[\matV_1 \dots \matV_k \;\vert\; \widehat{\matC}]^\top \from \samplepre(\matB, \matT, \matU, s_1)$.
				\item Set $C \coloneqq \matG \widehat{\matC}$.
				\item Set $\Opening_i \coloneqq \matV_i$ for $i \in [\arity]$.
				\item Return $(C, \Opening_1,\ldots,\Opening_\arity)$.
			\end{enumerate}
		\end{itemize}
		\begin{itemize}[noitemsep]
			\item[] $\commitment.\open_{\comkey}(\Message, \Opening) = C \in M$ 
			\begin{enumerate}[nolistsep]
				\item Return $\comkey \cdot \Opening - \Message$.
			\end{enumerate}
		\end{itemize}
\end{construction}
